# Desktop for Web3 - 测试验证清单

> 每次代码修改后必须执行的完整测试流程

---

## 测试前准备

### 测试环境要求
1. 启动开发服务器: `npm run dev`
2. 等待服务器就绪（约 3-5 秒）
3. 导航到: `http://localhost:5173/src/newtab/index.html`
4. 清除浏览器存储（确保干净的初始状态）

### 测试视口尺寸
- **标准**: 1920x1080 (常见桌面分辨率)
- **小屏**: 1200x800 (小笔记本)
- **大屏**: 2560x1440 (高分辨率显示器)

---

## 1. 默认组件完整性验证

### 测试目的
验证所有默认组件在初始化后正确显示，确保没有任何组件缺失或位置异常。

### 验证步骤
1. 打开页面，等待加载完成
2. 检查控制台是否有 `[App] Initialized` 日志
3. 在页面中查找以下组件：

#### 固定元素（第一行）
- [ ] **时间组件**: 显示当前时间和日期，位于第一行左侧
- [ ] **搜索框**: 显示 "Search web3" 占位符，位于第一行居中

#### Widget 组件（左侧区域）
- [ ] **链上监控 (Chain Monitor)**: 位于时间组件下方，显示 BTC/ETH/SOL 数据
- [ ] **日历 (Calendar)**: 位于链上监控下方
- [ ] **价格监控 (Watchlist)**: 位于日历下方

#### 资讯组件（右侧区域）
- [ ] **资讯 (News)**: 位于搜索框右侧，显示 Web3 资讯列表

#### 应用图标（中间区域）
- [ ] **CEX 图标** (4个): Binance, OKX, Bybit, Coinbase, Kraken
- [ ] **DEX 图标** (3个): Uniswap, PancakeSwap, Curve
- [ ] 总共 8 个图标，排列在搜索框下方

### 预期结果
- 总共 **10 个元素** 正确显示
- 所有组件位置符合设计布局
- 没有组件重叠
- 所有组件都在 viewport 可见范围内

### 失败诊断
- 如果组件缺失: 检查 `initializeDefaultElements()` 是否正确调用
- 如果位置异常: 检查 `getCenteredPosition()` 计算是否正确
- 如果组件重叠: 检查 grid 系统边界计算

---

## 2. Grid System 居中验证

### 测试目的
验证 Grid 区域在容器中水平居中，搜索框在 Grid 区域中居中。

### 验证步骤

#### A. Grid 区域居中检查
1. 使用开发者工具检查 `.grid-container` 元素
2. 获取 `.grid-area` 元素的尺寸和位置
3. 计算左侧间距和右侧间距
4. 验证两侧间距是否相等

**预期结果:**
- `areaLeft` 和 `areaRight` 相差不超过 1px
- Grid 区域在容器中水平居中

#### B. 搜索框居中检查
1. 计算 Grid 区域的中心点: `gridRect.left + gridRect.width / 2`
2. 计算搜索框的中心点: `searchRect.left + searchRect.width / 2`
3. 计算两个中心点的差值

**预期结果:**
- 偏移量在可接受范围内（≤ 0.5 列 = 40px）
- 注: 奇数列 grid 与偶数宽元素无法完美居中

### 计算公式参考
```
Grid 单元尺寸 = 86px (GRID_UNIT) - 更新于 2025-01-14
Grid 间隙 = 8px (GRID_GAP)
单元格尺寸 = 86 + 8 = 94px

Grid 列数 = floor((viewport宽度 - 72 - 32) / 94)
Grid 区域宽度 = 列数 × 86 + (列数 - 1) × 8
```

---

## 3. Grid Unit 固定尺寸验证

### 测试目的
验证 Grid Unit 和 Grid Gap 在不同视口尺寸下保持固定值。

### 验证步骤
1. 在不同视口尺寸下测试: 1200px, 1920px, 2560px
2. 测量图标组件的宽度和高度
3. 测量资讯组件的宽度
4. 验证尺寸是否符合设计规范

**预期结果（所有视口尺寸）:**
- 图标: 72px × 72px
- 资讯宽度: 152px (2 × 72 + 8)
- Grid Unit: 72px
- Grid Gap: 8px
- 图标间间隙: 8px

### 失败诊断
- 如果尺寸变化: 检查是否使用了百分比或其他相对单位
- 如果间隙异常: 检查 `GRID_GAP` 常量是否正确

---

## 4. 动态列数计算验证

### 测试目的
验证 Grid System 列数根据视口宽度动态计算，Grid 区域填满可用宽度。

### 测试数据参考

| 视口宽度 | Sidebar + Padding | 可用宽度 | 列数 | Grid 区域宽度 |
|----------|-------------------|----------|------|--------------|
| 1200px | 104px | 1096px | 13 | 1032px |
| 1920px | 104px | 1816px | 22 | 1752px |
| 2560px | 104px | 2456px | 30 | 2392px |

### 验证步骤
1. 在不同视口宽度下获取 `.grid-area` 的实际宽度
2. 根据公式计算期望的列数和宽度
3. 对比实际值与期望值

**预期结果:**
- 实际列数与期望列数一致
- 实际宽度与期望宽度相差不超过 1px

---

## 5. 拖拽功能验证

### 5.1 固定元素不可拖拽

**测试目的**: 验证时间组件和搜索框不可被拖拽。

**验证步骤:**
1. 尝试点击并拖拽时间组件
2. 尝试点击并拖拽搜索框
3. 观察元素是否移动

**预期结果:**
- 时间组件和搜索框不响应拖拽
- 鼠标光标为 `default`（不是 `move`）
- 元素有 `grid-element--fixed` 类

### 5.2 可拖拽元素验证

**测试目的**: 验证 Widget 和图标可以被拖拽。

**验证步骤:**
1. 鼠标悬停在资讯组件或图标上
2. 观察鼠标光标是否变为 `move`
3. 点击并拖拽元素

**预期结果:**
- 鼠标悬停时光标变为 `move`
- 元素可以被拖拽移动
- 拖拽时元素变为半透明（opacity: 0.9）
- 拖拽时元素放大 1.05 倍

### 5.3 阴影预览效果

**测试目的**: 验证拖拽时显示阴影预览，指示释放后将吸附的位置。

**验证步骤:**
1. 拖拽一个图标或 Widget
2. 观察是否显示蓝色虚线边框的占位符
3. 观察占位符是否对应目标 grid 位置

**预期结果:**
- 显示蓝色半透明占位符（`rgba(59, 130, 246, 0.25)`）
- 占位符有虚线边框
- 占位符位置对应释放后的吸附位置
- 阴影效果在深色背景下可见

### 5.4 拖拽边界检测

**测试目的**: 验证元素不能被拖拽到 Grid 边界之外。

**验证步骤:**
1. 拖拽一个图标到最左侧边界
2. 尝试继续向左拖拽
3. 观察元素是否被限制在边界内
4. 对右侧、上侧边界重复测试

**预期结果:**
- 元素不能超出 Grid 区域边界
- 元素不能被拖拽到 viewport 之外
- 如果尝试拖出边界，元素自动限制在边界内

---

## 6. 拖拽挤压方向验证

### 测试目的
验证元素被挤压时优先向右侧（有空白区域的方向）移动，而不是向下挤压导致超出 viewport。

### 验证步骤
1. 拖拽一个图标到资讯组件右侧
2. 观察资讯组件的移动方向
3. 验证资讯组件是否向右移动而不是向下

**预期结果:**
- 资讯组件向右移动到下一个可用位置
- 资讯组件不被挤压到 viewport 下方
- 如果右侧有足够空间，元素优先向右挤压

### 失败诊断
- 如果元素向下挤压: 检查 BFS 算法的方向顺序
- 方向应优先: 右 → 下 → 左 → 上

---

## 7. 元素释放与吸附验证

### 测试目的
验证元素释放后正确吸附到 Grid 位置，被挤压的元素正确移动到新位置。

### 验证步骤
1. 拖拽一个图标到新位置
2. 释放鼠标
3. 观察元素是否吸附到最近的 grid 位置
4. 观察其他元素是否正确响应挤压

**预期结果:**
- 拖拽的元素吸附到 grid 位置
- 被影响的元素平滑移动到新位置
- 未被影响的元素保持原位置
- 位置刷新后保持不变（持久化）

---

## 8. 响应式行为验证

### 测试目的
验证窗口 resize 时 Grid System 正确重新计算。

### 验证步骤
1. 打开页面，记住当前布局
2. 调整浏览器窗口大小
3. 观察 Grid 区域是否重新计算尺寸
4. 观察元素尺寸是否保持不变

**预期结果:**
- 窗口变大时: Grid 列数增加，显示更多空白区域
- 窗口变小时: Grid 列数减少（最小6列）
- 元素尺寸始终保持 72px 单元大小
- 元素间隙始终保持 8px

---

## 9. 视觉回归验证

### 截图对比
在不同视口尺寸下截图并对比：
- 1920x1080: `layout-1920.png`
- 2560x1440: `layout-2560.png`
- 1200x800: `layout-1200.png`

**验证要点:**
- 搜索框始终居中
- 元素不超出 viewport
- 布局符合设计规范

---

## 10. 控制台错误检查

### 验证步骤
1. 打开开发者工具 Console 面板
2. 检查是否有 JavaScript 错误

**预期结果:**
- 无运行时错误
- 无 `undefined` 相关错误
- 仅允许 favicon 404 错误（非关键）

---

## 通用工作流程

### 测试前准备
1. 启动开发服务器: `npm run dev`
2. 等待服务器就绪（约 3-5 秒）
3. 导航到: `http://localhost:5173/src/newtab/index.html`
4. 清除浏览器存储（确保干净的初始状态）

### 测试后清理（每次工作结束必须执行）
```bash
# 关闭所有开发服务器
pkill -f "npm run dev"
pkill -f "vite"
lsof -ti :5173-5180 | xargs kill -9 2>/dev/null

# 关闭所有浏览器标签页
# 通过 MCP 工具手动关闭所有打开的页面
```

**重要**: 每次测试/开发工作结束后，必须：
- ✅ 关闭所有后台运行的 npm/node 进程
- ✅ 关闭所有通过 MCP 打开的浏览器标签页
- ✅ 释放系统资源，避免内存泄漏

---

## 快速测试命令

```bash
# 启动开发服务器
npm run dev

# 构建检查
npm run build

# 类型检查
npm run type-check

# 清理后台进程（测试后执行）
pkill -f "npm run dev" && pkill -f "vite"
```

---

## 测试通过标准

一个版本被认为"测试通过"需要满足：

- [ ] **默认组件完整**: 所有 14 个组件正确显示
- [ ] **Grid 居中**: Grid 区域在容器中水平居中
- [ ] **搜索框居中**: 搜索框尽可能居中（误差 ≤ 0.5 列）
- [ ] **Grid Unit 固定**: 所有视口下保持 72px
- [ ] **动态列数**: 列数根据视口正确计算
- [ ] **固定元素不可拖拽**: 时间和搜索框无法被拖拽
- [ ] **可拖拽元素可拖拽**: 图标和 Widget 可正常拖拽
- [ ] **阴影预览可见**: 拖拽时蓝色阴影预览清晰可见
- [ ] **挤压方向正确**: 优先向右挤压而非向下
- [ ] **无控制台错误**: 无 JavaScript 运行时错误

---

## 当前状态跟踪

| 测试类别 | 最后执行时间 | 结果 | 备注 |
|----------|-------------|------|------|
| 默认组件完整性 | - | - | 待执行 |
| Grid 居中验证 | - | - | 待执行 |
| Grid Unit 验证 | - | - | 待执行 |
| 动态列数验证 | - | - | 待执行 |
| 拖拽功能 | - | - | 待执行 |
| 阴影预览 | - | - | 待执行 |
| 挤压方向 | - | - | 待执行 |
| 响应式行为 | - | - | 待执行 |

---

## 已知限制

1. **奇数列居中**: 当 grid 列数为奇数时，偶数宽度的元素无法完美居中，最大偏移为 0.5 列 (40px)

2. **最小视口**: Grid 最小列数为 6，视口过小时可能出现水平滚动条

3. **浏览器兼容**: 毛玻璃效果 (`backdrop-filter`) 在某些旧浏览器中不支持

---

## 附录: 快速诊断脚本

### 检查所有元素
```javascript
document.querySelectorAll('[data-element-id]').forEach(el => {
  console.log(el.getAttribute('data-element-id'), el.getBoundingClientRect());
})
```

### 检查 Grid 尺寸
```javascript
const gridArea = document.querySelector('.grid-area');
console.log('Grid area:', gridArea.getBoundingClientRect());
```

### 清除存储重新测试
```javascript
chrome.storage.local.clear();
location.reload();
```
